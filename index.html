<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q&A Knowledge Base Cleanup Tool</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'abnormal-blue': '#1e40af',
                        'abnormal-dark': '#1e293b',
                        'abnormal-purple': '#7c3aed',
                        'abnormal-light': '#f8fafc',
                        'abnormal-accent': '#3b82f6'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-abnormal-light">
    <div id="root"></div>

```
<script type="text/babel">
    const { useState, useEffect } = React;

    // Lucide React icons as inline SVG components
    const Search = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="21 21l-4.35-4.35"></path>
        </svg>
    );

    const Upload = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17,8 12,3 7,8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
    );

    const Download = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7,10 12,15 17,10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
    );

    const Edit3 = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="12 20h9"></path>
            <path d="16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
        </svg>
    );

    const CheckCircle = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
            <polyline points="22,4 12,14.01 9,11.01"></polyline>
        </svg>
    );

    const X = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
    );

    const Trash2 = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polyline points="3,6 5,6 21,6"></polyline>
            <path d="19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2v4a2 2 0 0 1 2 2v2"></path>
            <line x1="10" y1="11" x2="10" y2="17"></line>
            <line x1="14" y1="11" x2="14" y2="17"></line>
        </svg>
    );

    const FileSpreadsheet = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="14,2 H6 A2,2 0 0,0 4,4 V20 A2,2 0 0,0 6,22 H18 A2,2 0 0,0 20,20 V8 Z"></path>
            <polyline points="14,2 14,8 20,8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10,9 9,9 8,9"></polyline>
        </svg>
    );

    const AlertCircle = () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
        </svg>
    );

    const Eye = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    );

    const Star = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
    );

    const RotateCcw = () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polyline points="1,4 1,10 7,10"></polyline>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
        </svg>
    );

    const QACleanupTool = () => {
        const [qaPairs, setQaPairs] = useState([]);
        const [filteredPairs, setFilteredPairs] = useState([]);
        const [selectedPair, setSelectedPair] = useState(null);
        const [searchTerm, setSearchTerm] = useState('');
        const [filter, setFilter] = useState('all');
        const [editingPair, setEditingPair] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [uploadError, setUploadError] = useState(null);
        const [isProcessing, setIsProcessing] = useState(false);
        const [finalizedPairs, setFinalizedPairs] = useState([]);
        const [deletedPairs, setDeletedPairs] = useState([]);
        const [currentView, setCurrentView] = useState('review'); // 'review', 'finalized', 'deleted'
        const [duplicateGroups, setDuplicateGroups] = useState([]);

        // Initialize with empty data
        useEffect(() => {
            if (qaPairs.length === 0) {
                loadSampleData();
            }
        }, []);

        const loadSampleData = () => {
            const sampleData = generateSampleData();
            setQaPairs(sampleData);
            setFilteredPairs(sampleData);
            // Generate duplicate groups
            const groups = findDuplicateGroups(sampleData);
            setDuplicateGroups(groups);
        };

        // Advanced duplicate detection using semantic similarity
        const findDuplicateGroups = (data) => {
            const groups = [];
            const processed = new Set();

            data.forEach((item, index) => {
                if (processed.has(item.id)) return;

                const similar = data.filter((other, otherIndex) => {
                    if (otherIndex <= index || processed.has(other.id)) return false;
                    return calculateAdvancedSimilarity(item.question, other.question) > 0.75;
                });

                if (similar.length > 0) {
                    const group = [item, ...similar];
                    groups.push(group);
                    group.forEach(pair => processed.add(pair.id));
                }
            });

            return groups;
        };

        // Advanced similarity calculation using multiple techniques
        const calculateAdvancedSimilarity = (str1, str2) => {
            // Normalize strings
            const normalize = (str) => str.toLowerCase().replace(/[^\w\s]/g, '').trim();
            const norm1 = normalize(str1);
            const norm2 = normalize(str2);

            // Exact match
            if (norm1 === norm2) return 1.0;

            // Jaccard similarity (word-based)
            const words1 = new Set(norm1.split(/\s+/));
            const words2 = new Set(norm2.split(/\s+/));
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);
            const jaccard = intersection.size / union.size;

            // Levenshtein-based similarity
            const maxLen = Math.max(str1.length, str2.length);
            const levenshtein = 1 - (levenshteinDistance(norm1, norm2) / maxLen);

            // Semantic keyword matching
            const keywords1 = extractKeywords(norm1);
            const keywords2 = extractKeywords(norm2);
            const keywordSim = calculateKeywordSimilarity(keywords1, keywords2);

            // Weighted combination
            return (jaccard * 0.4) + (levenshtein * 0.3) + (keywordSim * 0.3);
        };

        const levenshteinDistance = (str1, str2) => {
            const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
            
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + cost
                    );
                }
            }
            
            return matrix[str2.length][str1.length];
        };

        const extractKeywords = (text) => {
            const stopWords = new Set(['what', 'how', 'do', 'we', 'our', 'the', 'is', 'are', 'for', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'of', 'with', 'by']);
            return text.split(/\s+/).filter(word => word.length > 2 && !stopWords.has(word));
        };

        const calculateKeywordSimilarity = (keywords1, keywords2) => {
            if (keywords1.length === 0 || keywords2.length === 0) return 0;
            const set1 = new Set(keywords1);
            const set2 = new Set(keywords2);
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            return intersection.size / Math.max(set1.size, set2.size);
        };

        // File upload handler
        const handleFileUpload = async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            setIsLoading(true);
            setUploadError(null);

            try {
                const data = await readExcelFile(file);
                const processedData = await processQAData(data);
                setQaPairs(processedData);
                setFilteredPairs(processedData);
                
                // Generate duplicate groups
                const groups = findDuplicateGroups(processedData);
                setDuplicateGroups(groups);
                
                // Reset other states
                setSelectedPair(null);
                setEditingPair(null);
                setSearchTerm('');
                setFilter('all');
                setCurrentView('review');
                setFinalizedPairs([]);
                setDeletedPairs([]);
                
            } catch (error) {
                setUploadError(error.message);
            } finally {
                setIsLoading(false);
            }
        };

        // Read Excel file
        const readExcelFile = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        resolve(jsonData);
                    } catch (error) {
                        reject(new Error('Failed to read Excel file. Please check the file format.'));
                    }
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        };

        // Process Q&A data
        const processQAData = async (rawData) => {
            setIsProcessing(true);
            
            return new Promise((resolve) => {
                setTimeout(() => {
                    try {
                        if (rawData.length < 2) {
                            throw new Error('File must contain at least a header row and one data row');
                        }

                        const headers = rawData[0].map(h => h?.toString().toLowerCase().trim());
                        const rows = rawData.slice(1);

                        const questionCol = findColumn(headers, ['question', 'q', 'query', 'ask']);
                        const answerCol = findColumn(headers, ['answer', 'a', 'response', 'reply']);

                        if (questionCol === -1 || answerCol === -1) {
                            throw new Error('Could not find Question and Answer columns. Please ensure your Excel has columns named "Question" and "Answer"');
                        }

                        const processedData = rows
                            .filter(row => row[questionCol] && row[answerCol])
                            .map((row, index) => {
                                const question = row[questionCol]?.toString().trim();
                                const answer = row[answerCol]?.toString().trim();
                                
                                const tagCol = findColumn(headers, ['tags', 'tag', 'category', 'categories']);
                                const tags = tagCol !== -1 && row[tagCol] 
                                    ? row[tagCol].toString().split(',').map(t => t.trim()).filter(t => t)
                                    : inferTags(question, answer);

                                const issues = detectIssues(question, answer);
                                const confidence = calculateConfidence(question, answer, issues);

                                return {
                                    id: index + 1,
                                    question,
                                    answer,
                                    tags,
                                    lastUpdated: new Date().toISOString().split('T')[0],
                                    issues,
                                    confidence
                                };
                            });

                        resolve(processedData);
                    } catch (error) {
                        throw error;
                    } finally {
                        setIsProcessing(false);
                    }
                }, 1000);
            });
        };

        const findColumn = (headers, possibleNames) => {
            for (let name of possibleNames) {
                const index = headers.findIndex(h => h.includes(name));
                if (index !== -1) return index;
            }
            return -1;
        };

        const inferTags = (question, answer) => {
            const text = (question + ' ' + answer).toLowerCase();
            const tagMap = {
                security: ['encrypt', 'security', 'auth', 'password', 'secure', 'firewall', 'malware', 'threat', 'vulnerability', 'breach'],
                compliance: ['compliance', 'audit', 'cert', 'gdpr', 'hipaa', 'sox', 'iso', 'regulation', 'legal', 'policy'],
                privacy: ['privacy', 'personal', 'pii', 'data protection', 'consent', 'right to', 'delete', 'export'],
                infrastructure: ['server', 'cloud', 'backup', 'system', 'network', 'infrastructure', 'uptime', 'monitoring'],
                support: ['support', 'help', 'ticket', 'response', 'service level', 'sla', 'customer'],
                legal: ['legal', 'contract', 'agreement', 'terms', 'liability', 'warranty', 'jurisdiction'],
                finance: ['billing', 'payment', 'cost', 'price', 'invoice', 'refund', 'subscription'],
                integration: ['api', 'integration', 'connect', 'webhook', 'sync', 'import', 'export']
            };

            const detectedTags = [];
            Object.entries(tagMap).forEach(([tag, keywords]) => {
                if (keywords.some(keyword => text.includes(keyword))) {
                    detectedTags.push(tag);
                }
            });

            return detectedTags.length > 0 ? detectedTags : ['general'];
        };

        const detectIssues = (question, answer) => {
            const issues = [];

            if (answer.length < 50 || 
                answer.toLowerCase().includes('we follow best practices') ||
                answer.toLowerCase().includes('industry standard') ||
                answer.toLowerCase().includes('as needed')) {
                issues.push('vague');
            }

            if (answer.includes('TLS 1.2') && answer.includes('TLS 1.3')) {
                issues.push('inconsistent');
            }

            return issues;
        };

        const calculateConfidence = (question, answer, issues) => {
            let score = 100;
            
            if (issues.includes('vague')) score -= 30;
            if (issues.includes('inconsistent')) score -= 20;
            
            if (answer.length < 30) score -= 20;
            if (question.length < 10) score -= 15;
            
            return Math.max(score, 10);
        };

        const generateSampleData = () => {
            const questionTemplates = [
                { template: "What encryption do we use for {type}?", category: "security", variations: ["data at rest", "data in transit", "databases", "communications", "file storage", "customer data", "internal systems"] },
                { template: "Do we have {standard} certification?", category: "compliance", variations: ["SOC 2", "ISO 27001", "GDPR", "HIPAA", "PCI DSS", "FedRAMP", "SOX"] },
                { template: "How long do we retain {data_type}?", category: "privacy", variations: ["customer data", "logs", "backups", "metadata", "audit trails", "user information", "transaction data"] },
                { template: "How do we handle {event}?", category: "security", variations: ["data breaches", "security incidents", "access violations", "suspicious activity", "malware detection", "phishing attempts"] },
                { template: "What is our {policy} policy?", category: "compliance", variations: ["data retention", "password", "access control", "backup", "incident response", "privacy", "security"] },
                { template: "Can customers {action}?", category: "privacy", variations: ["delete their data", "export their data", "opt out", "request copies", "modify data", "access their information"] },
                { template: "What {technology} do we use?", category: "infrastructure", variations: ["cloud provider", "monitoring tools", "backup solution", "database system", "security tools", "encryption methods"] },
                { template: "How often do we {action}?", category: "infrastructure", variations: ["backup data", "update systems", "patch servers", "monitor logs", "test DR", "review access"] },
            ];

            const answers = {
                security: [
                    "We use AES-256 encryption for all data at rest and TLS 1.3 for data in transit with perfect forward secrecy.",
                    "Our security team follows NIST incident response procedures with 24/7 monitoring and automated alerting systems.",
                    "All access is managed through our identity management system with multi-factor authentication required for all users.",
                    "We deploy endpoint protection, network security, and email filtering with real-time threat intelligence feeds."
                ],
                compliance: [
                    "Yes, we maintain current certification and undergo annual audits by independent third-party assessors.",
                    "Our compliance team ensures adherence to all applicable regulations with quarterly internal assessments.",
                    "We have implemented comprehensive policies that are reviewed annually and updated as regulations change.",
                    "All staff receive regular training on compliance requirements with documented completion tracking."
                ],
                privacy: [
                    "Customers have full control over their data through our privacy portal with self-service options available 24/7.",
                    "We only share data as outlined in our privacy policy with explicit consent and under signed agreements.",
                    "Data is retained according to our published retention policy which complies with all applicable regulations.",
                    "We provide transparent reporting on all data processing activities through quarterly privacy reports."
                ],
                infrastructure: [
                    "We use enterprise-grade cloud infrastructure with 99.9% uptime SLA across multiple availability zones.",
                    "Our systems are monitored 24/7 with automated alerting and response capabilities for critical events.",
                    "We maintain redundant systems across multiple geographic regions with automated failover capabilities.",
                    "All infrastructure changes follow our change management process with proper testing and rollback procedures."
                ]
            };

            const data = [];
            let id = 1;

            // Generate multiple rounds to reach sample size
            for (let round = 0; round < 150; round++) {
                questionTemplates.forEach(template => {
                    template.variations.forEach(variation => {
                        const questionVariations = [
                            template.template.replace(/\{[^}]+\}/g, variation),
                            template.template.replace(/\{[^}]+\}/g, variation).replace('What', 'Can you explain what'),
                            template.template.replace(/\{[^}]+\}/g, variation).replace('How', 'Please describe how'),
                            template.template.replace(/\{[^}]+\}/g, variation).replace('Do we', 'Does the company'),
                        ];
                        
                        const question = questionVariations[round % questionVariations.length];
                        const answerOptions = answers[template.category];
                        const answer = answerOptions[Math.floor(Math.random() * answerOptions.length)];
                        
                        const issues = [];
                        if (Math.random() < 0.08) issues.push('vague');
                        if (Math.random() < 0.05) issues.push('inconsistent');
                        
                        const confidence = issues.length > 0 ? Math.floor(Math.random() * 30) + 50 : Math.floor(Math.random() * 20) + 80;
                        
                        data.push({
                            id: id++,
                            question,
                            answer,
                            tags: [template.category],
                            lastUpdated: "2024-01-15",
                            issues,
                            confidence
                        });

                        if (data.length >= 900) return data.slice(0, 900);
                    });
                    if (data.length >= 900) return data.slice(0, 900);
                });
                if (data.length >= 900) return data.slice(0, 900);
            }

            return data.slice(0, 900);
        };

        // Get pairs based on current view
        const getCurrentPairs = () => {
            switch(currentView) {
                case 'finalized': return finalizedPairs;
                case 'deleted': return deletedPairs;
                default: return qaPairs;
            }
        };

        // Filter logic
        useEffect(() => {
            let filtered = getCurrentPairs();

            if (searchTerm) {
                filtered = filtered.filter(pair => 
                    pair.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    pair.answer.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    pair.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
                );
            }

            if (filter !== 'all') {
                filtered = filtered.filter(pair => {
                    switch(filter) {
                        case 'duplicates': 
                            return duplicateGroups.some(group => 
                                group.some(duplicate => duplicate.id === pair.id)
                            );
                        default: return true;
                    }
                });
            }

            setFilteredPairs(filtered);
        }, [searchTerm, filter, qaPairs, finalizedPairs, deletedPairs, currentView, duplicateGroups]);

        const getIssueColor = (issue) => {
            switch(issue) {
                case 'duplicate': return 'bg-yellow-100 text-yellow-800 border-yellow-200';
                case 'inconsistent': return 'bg-orange-100 text-orange-800 border-orange-200';
                case 'vague': return 'bg-gray-100 text-gray-800 border-gray-200';
                default: return 'bg-blue-100 text-blue-800 border-blue-200';
            }
        };

        const handleEdit = (pair) => {
            setEditingPair({...pair});
        };

        const handleSave = () => {
            if (currentView === 'review') {
                setQaPairs(prev => prev.map(p => p.id === editingPair.id ? editingPair : p));
            } else if (currentView === 'finalized') {
                setFinalizedPairs(prev => prev.map(p => p.id === editingPair.id ? editingPair : p));
            }
            setEditingPair(null);
        };

        const handleDelete = (id) => {
            if (currentView === 'review') {
                const pairToDelete = qaPairs.find(p => p.id === id);
                setDeletedPairs(prev => [...prev, pairToDelete]);
                setQaPairs(prev => prev.filter(p => p.id !== id));
            } else if (currentView === 'finalized') {
                const pairToDelete = finalizedPairs.find(p => p.id === id);
                setDeletedPairs(prev => [...prev, pairToDelete]);
                setFinalizedPairs(prev => prev.filter(p => p.id !== id));
            } else if (currentView === 'deleted') {
                setDeletedPairs(prev => prev.filter(p => p.id !== id));
            }
            
            if (selectedPair && selectedPair.id === id) {
                setSelectedPair(null);
            }
        };

        const handleFinalize = (id) => {
            const pairToFinalize = qaPairs.find(p => p.id === id);
            setFinalizedPairs(prev => [...prev, pairToFinalize]);
            setQaPairs(prev => prev.filter(p => p.id !== id));
            if (selectedPair && selectedPair.id === id) {
                setSelectedPair(null);
            }
        };

        const handleRestore = (id) => {
            if (currentView === 'deleted')
```
